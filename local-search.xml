<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>归并排序和快速排序</title>
    <link href="/2023/10/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/10/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="1、二路归并排序："><a href="#1、二路归并排序：" class="headerlink" title="1、二路归并排序："></a>1、二路归并排序：</h4><p>&emsp;&emsp;最初将长度为n的原始数组分为由n个长度为1的按值有序的子数组成，并把这些子数组中相邻的子数组两两成对地合并，若n为奇数，则还有第[n&#x2F;2]个子数组；然后将这些子数组又两两进行合并，最后只剩下一个长度为n的有序数组。<br>&emsp;&emsp;实际在程序中的运行步骤为： </p><span id="more"></span><p><img src="/img/image-51.png" alt="image-51"><br><img src="/img/image-52.png" alt="image-52">  </p><h4 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h4><p>&emsp;&emsp;先选择出一个元素作为主元来作为划分的依据，把小于主元的的所有元素移到主元左边；大于主元的所有元素移到右边；最后主元归位。然后分别对这两个子数组递归进行上述过程，直到所有元素都在最终位置上。<br>&emsp;&emsp;运行步骤图解为：<br><img src="/img/image-53.png" alt="image-53"><br><img src="/img/image-54.png" alt="image-54"></p><h4 id="功能模块设计"><a href="#功能模块设计" class="headerlink" title="功能模块设计"></a>功能模块设计</h4><h5 id="1-二路归并排序"><a href="#1-二路归并排序" class="headerlink" title="1. 二路归并排序"></a>1. 二路归并排序</h5><ol><li>先将数组拆分，采用递归改变函数参数的值来模拟实现改变数组子数组大小：     <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (l<span class="hljs-operator"> == </span>h)<br>         return <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span>&#125;;<br>     <span class="hljs-comment">//求中间值,</span><br>     <span class="hljs-built_in">int</span> mid = l + (h - l)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<span class="hljs-comment">//防止整形溢出</span><br>     <span class="hljs-comment">// 注意此时的l和h的改变，该步骤相当于将数组分开的过程</span><br>     <span class="hljs-comment">//递归排序左数组，最先mid一直迭代，直到mid=0</span><br>     <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> leftArr = my<span class="hljs-constructor">MergeSort(<span class="hljs-params">nums</span>, <span class="hljs-params">l</span>, <span class="hljs-params">mid</span>)</span>;<br>     <span class="hljs-comment">//递归右排序</span><br>     <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> rightArr = my<span class="hljs-constructor">MergeSort(<span class="hljs-params">nums</span>, <span class="hljs-params">mid</span> + 1, <span class="hljs-params">h</span>)</span>;  <br></code></pre></td></tr></table></figure></li><li>new一个数组，用来合并排序后的成对子数组，数组长度为左右两数组的和，因为有单数和双数的情况，所以不是某边数组的两倍；   <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> leftArr = my<span class="hljs-constructor">MergeSort(<span class="hljs-params">nums</span>, <span class="hljs-params">l</span>, <span class="hljs-params">mid</span>)</span>;<br>     <span class="hljs-comment">//递归右排序</span><br>     <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> rightArr = my<span class="hljs-constructor">MergeSort(<span class="hljs-params">nums</span>, <span class="hljs-params">mid</span> + 1, <span class="hljs-params">h</span>)</span>;<br>     <span class="hljs-comment">//生成一个新数组，用来合并上述递归排序后的数组</span><br>     <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> newNum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">leftArr</span>.<span class="hljs-identifier">length</span> + <span class="hljs-identifier">rightArr</span>.<span class="hljs-identifier">length</span>]</span>;<br>```  <br></code></pre></td></tr></table></figure></li><li>往新数组依次插入元素通过i和j来判断此次比较的元素，如果左边数组元素插入，则i++；反之，则j++；剩余的元素随后一次性插入：    <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">int</span> m = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//往新数组按大小依次插入数据，三元运算符存入哪个数据，i/j++；</span><br>    <span class="hljs-keyword">while</span> (i &lt; leftArr.<span class="hljs-built_in">length</span> &amp;&amp; j &lt; rightArr.<span class="hljs-built_in">length</span>) &#123;<br>        newNum[m++] = leftArr[i] &lt; rightArr[j] ? leftArr[i++] : rightArr[j++];<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>以下为全部代码     <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> my<span class="hljs-constructor">MergeSort(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">h</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (l<span class="hljs-operator"> == </span>h) return <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span>&#125;;<br>    <span class="hljs-comment">//求中间值,</span><br>    <span class="hljs-built_in">int</span> mid = l + (h - l)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 注意此时的l和h的改变，该步骤相当于将数组分开的过程</span><br>    <span class="hljs-comment">//递归排序左数组，最先mid一直迭代，直到mid=0</span><br>    <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> leftArr = my<span class="hljs-constructor">MergeSort(<span class="hljs-params">nums</span>, <span class="hljs-params">l</span>, <span class="hljs-params">mid</span>)</span>;<br>    <span class="hljs-comment">//递归右排序</span><br>    <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> rightArr = my<span class="hljs-constructor">MergeSort(<span class="hljs-params">nums</span>, <span class="hljs-params">mid</span> + 1, <span class="hljs-params">h</span>)</span>;<br>    <span class="hljs-comment">//生成一个新数组，用来合并上述递归排序后的数组</span><br>    <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> newNum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">leftArr</span>.<span class="hljs-identifier">length</span> + <span class="hljs-identifier">rightArr</span>.<span class="hljs-identifier">length</span>]</span>;<br>    <span class="hljs-comment">//合并</span><br>    <span class="hljs-built_in">int</span> m = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(leftArr<span class="hljs-literal">[<span class="hljs-identifier">leftArr</span>.<span class="hljs-identifier">length</span>-<span class="hljs-number">1</span>]</span>&gt;rightArr<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>)&#123;<br>    <span class="hljs-comment">//往新数组按大小依次插入数据，三元运算符存入哪个数据，i/j++；</span><br>        <span class="hljs-keyword">while</span> (i &lt; leftArr.length<span class="hljs-operator"> &amp;&amp; </span>j &lt; rightArr.length) &#123;<br>            newNum<span class="hljs-literal">[<span class="hljs-identifier">m</span><span class="hljs-operator">++</span>]</span> = leftArr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt; rightArr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> ? leftArr<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span> : rightArr<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果只剩下左边数组有数据，将剩余数据插入</span><br>        <span class="hljs-keyword">while</span> (i &lt; leftArr.length)<br>        newNum<span class="hljs-literal">[<span class="hljs-identifier">m</span><span class="hljs-operator">++</span>]</span> = leftArr<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>        <span class="hljs-comment">//如果只剩下左边数组有数据，将剩余数据插入</span><br>        <span class="hljs-keyword">while</span> (j &lt; rightArr.length)<br>        newNum<span class="hljs-literal">[<span class="hljs-identifier">m</span><span class="hljs-operator">++</span>]</span> = rightArr<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>arraycopy(leftArr,<span class="hljs-number">0</span>,newNum,<span class="hljs-number">0</span>,leftArr.length);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>arraycopy(rightArr,<span class="hljs-number">0</span>,newNum,left.length,rightArr.length);<br>    &#125;<br>    return newNum;<br>&#125;  <br></code></pre></td></tr></table></figure></li></ol><h5 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h5><ol><li>选主元，此处使用数组第一位作为主元     <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>temp就是主元<br>temp = nums[low];<span class="hljs-regexp">//</span>low为数组第一位<br></code></pre></td></tr></table></figure></li><li>通过改变i,j的值改变数组位置，也通过i、j的值来确定主元的位置；如果i（j)不满足条件，则向右（左）移动i（j），即i++（j–）；直到i和j均满足条件；然后交换i和j位置所对应的元素；如果此时上述步骤仍满足i&lt;j，继续循环上述步骤，直到i&gt;&#x3D;j，确保划分为左右数组：    <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">   <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>    <span class="hljs-regexp">//</span>先看右边，依次往左递减，直到找到小于主元的元素<br>    <span class="hljs-regexp">//i</span>&lt;j确保i,j位置正确<br>    <span class="hljs-keyword">while</span> (temp &lt;= nums[j] &amp;&amp; i &lt; j) &#123;<br>        j--;<br>    &#125;<br>    <span class="hljs-regexp">//</span>再看左边，依次往右递增，直到找到大于主元的元素<br>    <span class="hljs-keyword">while</span> (temp &gt;= nums[i] &amp;&amp; i &lt; j) &#123;<br>        i++;<br>    &#125;<br>    <span class="hljs-regexp">//</span>如果满足条件则交换<br>    <span class="hljs-regexp">//</span> 此判断条件防止i和j在进行上述两步骤的时候，i和j交换浪费时间<br>    <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>        t = nums[j];<br>        nums[j] = nums[i];<br>        nums[i] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>然后让主元归位     <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">   //最后将主演为与i相等位置的数字交换，让主元归位<br>nums[low] <span class="hljs-operator">=</span> nums[i]<span class="hljs-comment">;</span><br>nums[i] <span class="hljs-operator">=</span> temp<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>通过递归实现左右两边数组分开，分别让左右两边数组重复上述步骤     <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">   <span class="hljs-comment">//递归调用左边数组</span><br>my<span class="hljs-constructor">QuickSort(<span class="hljs-params">nums</span>, <span class="hljs-params">low</span>, <span class="hljs-params">i</span> - 1)</span>;<br><span class="hljs-comment">//递归调用右边数组</span><br>my<span class="hljs-constructor">QuickSort(<span class="hljs-params">nums</span>, <span class="hljs-params">i</span> + 1, <span class="hljs-params">high</span>)</span>;<br></code></pre></td></tr></table></figure></li><li>全部代码     <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs awk">public static void myQuickSort(int[] nums, int low, int high) &#123;<br>    int i, j, temp, t;<br>    <span class="hljs-regexp">//</span>保证数组下表左边小于右边，确保low所在位置的元素小于high所在位置的元素<br>    <span class="hljs-regexp">//</span> 保证主元位置正确<br>    <span class="hljs-keyword">if</span> (low &gt; high) return;<br>    i = low;<span class="hljs-regexp">//</span>low为数组低位，i为左边数组位置<br>    j = high;<span class="hljs-regexp">//</span>high为数组高位，j为右边数组位置<br>    <span class="hljs-regexp">//</span>temp就是主元<br>    temp = nums[low];<span class="hljs-regexp">//</span>low为数组第一位<br>    <span class="hljs-regexp">//</span>分别递归主元左右两边的元素，让左边元素都小于主元，右边元素都大于主元<br>    <span class="hljs-regexp">//i</span>的最终位置就是主演的位置<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-regexp">//</span>先看右边，依次往左递减，直到找到小于主元的元素<br>        <span class="hljs-regexp">//i</span>&lt;j确保i,j位置正确<br>        <span class="hljs-keyword">while</span> (temp &lt;= nums[j] &amp;&amp; i &lt; j) &#123;<br>            j--;&#125;<br>        <span class="hljs-regexp">//</span>再看左边，依次往右递增，直到找到大于主元的元素<br>        <span class="hljs-keyword">while</span> (temp &gt;= nums[i] &amp;&amp; i &lt; j) &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-regexp">//</span>如果满足条件则交换<br>        <span class="hljs-regexp">//</span> 此判断条件防止i和j在进行上述两步骤的时候，i和j交换浪费时间<br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>            t = nums[j];<br>            nums[j] = nums[i];<br>            nums[i] = t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-regexp">//</span>最后将主演为与i相等位置的数字交换，让主元归位<br>    nums[low] = nums[i];<br>    nums[i] = temp;<br>    <span class="hljs-regexp">//</span>递归调用左边数组<br>    myQuickSort(nums, low, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-regexp">//</span>递归调用右边数组<br>    myQuickSort(nums, i + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="文章参考："><a href="#文章参考：" class="headerlink" title="文章参考："></a>文章参考：</h5><p><a href="https://blog.csdn.net/weixin_45970271/article/details/124544051">https://blog.csdn.net/weixin_45970271/article/details/124544051</a><br><a href="https://blog.csdn.net/shujuelin/article/details/82423852">https://blog.csdn.net/shujuelin/article/details/82423852</a><br><a href="https://blog.csdn.net/justidle/article/details/104203958">https://blog.csdn.net/justidle/article/details/104203958</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop安装以及集群搭建</title>
    <link href="/2023/09/30/Hadoop%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/09/30/Hadoop%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<ol><li><p>设置Hadoop账户  </p></li><li><p>更新apt  </p><span id="more"></span><p><img src="/img/image.png" alt="image"></p></li><li><p>安装vim<br><img src="/img/image-1.png" alt="image-1"></p></li><li><p>安装SSH，用于远程登录<br><img src="/img/image-2.png" alt="image-2"></p></li><li><p>使用如下命令登录本机<br><img src="/img/image-3.png" alt="image-3"></p></li><li><p>下载jdk安装包，Ubuntu系统内下载，并且安装由于要使用百度网盘，需要安装一个软件，但是本次安装software打不开，下面为本次解决措施  </p><ol><li>重装software<br><img src="/img/image-8.png" alt="image-8"></li><li>下载jdk，并且配置<br><img src="/img/image-9.png" alt="image-9">  </li><li>进入vim配置环境变量<br><img src="/img/image-10.png" alt="image-10"><br><img src="/img/image-11.png" alt="image-11"></li><li>执行如下指令让.bashrc文件的配置生效<br><img src="/img/image-12.png" alt="image-12"></li><li>测试是否安装成功，若出现版本号则安装成功<br><img src="/img/image-13.png" alt="image-13"></li></ol></li><li><p>安装hadoop3.1.3<br><img src="/img/image-14.png" alt="image-14">  </p></li><li><p>克隆虚拟机，选择完整克隆</p></li><li><p>配置主机名和hosts列表  </p><ol><li>配置主机名，将原来的名称删掉，换成对应名称<br><img src="/img/image-15.png" alt="image-15"><br><img src="/img/image-16.png" alt="image-16"></li><li>配置hosts列表，将原来有127.0.1.1的那行删掉<br><img src="/img/image-18.png" alt="image-18"><br><img src="/img/image-19.png" alt="image-19"></li></ol></li><li><p>重启虚拟机，测试，ping  </p><ol><li>主机可ping<br><img src="/img/image-20.png" alt="image-20"></li><li>节点ping不通<br><img src="/img/image-21.png" alt="image-21"></li><li>打开相应节点虚拟机，发现能ping通了<br><img src="/img/image-22.png" alt="image-22"></li></ol></li><li><p>配置ssh免密匙登录<br>主机  </p><ol><li>生成~&#x2F;.ssh&#x2F;目录<br><img src="/img/image-23.png" alt="image-23"></li><li>生成密匙<br><img src="/img/image-24.png" alt="image-24"></li><li>加入授权，cat指令不仅有查看文件内容的功能，还可以连接文件；使用&gt;符号，表示重定向，会覆盖原来文件的内容，没有文件会自动创建；使用&gt;&gt;符号，表示追加内容，不会覆盖原文件内容<br><img src="/img/image-25.png" alt="image-25"></li><li>检测是否成功<br><img src="/img/image-26.png" alt="image-26"></li><li>将authorized_keys文件复制到slave节点的根目录下，需要在节点开机的情况下<br><img src="/img/image-27.png" alt="image-27"><br>节点</li></ol><p>slave2   </p><ol><li>生成密匙<br><img src="/img/image-28.png" alt="image-28"></li><li>将从master复制到slave的authorized_keys文件移动到slave中的.ssh文件夹中<br><img src="/img/image-29.png" alt="image-29"></li><li>修改slave中的authorized_keys文件的权限<br><img src="/img/image-30.png" alt="image-30"></li></ol></li><li><p>配置环境变量，三个虚拟机都要配置<br><img src="/img/image-31.png" alt="image-31"><br><img src="/img/image-32.png" alt="image-32"></p></li><li><p>配置hadoop内的env.sh<br><img src="/img/image-33.png" alt="image-33"><br><img src="/img/image-34.png" alt="image-34"><br><img src="/img/image-35.png" alt="image-35"><br><img src="/img/image-37.png" alt="image-37">  </p></li><li><p>配置hadoop<br><img src="/img/image-38.png" alt="image-38"><br><img src="/img/image-39.png" alt="image-39"><br><img src="/img/image-40.png" alt="image-40"><br><img src="/img/image-41.png" alt="image-41"><br><img src="/img/image-43.png" alt="image-43"></p><configuration>    <property>            <name>yarn.nodemanager.aux-services</name>            <value>mapreduce_shuffle</value>    </property>    <property>            <name>yarn.resourcemanager.hostname</name>            <value>master</value>    </property>    <property>            <name>yarn.resourcemanager.address</name>            <value>master:18040</value>    </property>    <property>            <name>yarn.resourcemanager.scheduler.address</name>            <value>master:18030</value>    </property>    <property>            <name>yarn.resourcemanager.resource-tracker.address</name>            <value>master:18025</value>    </property>    <property>            <name>yarn.resourcemanager.admin.address</name>            <value>master:18141</value>    </property>    <property>            <name>yarn.resourcemanager.webapp.address</name>            <value>master:18088</value>    </property>    <property>            <name>yarn.application.classpath</name>            <value>/usr/hadoop/hadoop/etc/hadoop:/usr/hadoop/hadoop/share/hadoop/common/lib/*:/usr/hadoop/hadoop/share/hadoop/common/*:/usr/hadoop/hadoop/share/hadoop/hdfs:/usr/hadoop/hadoop/share/hadoop/hdfs/lib/*:/usr/hadoop/hadoop/share/hadoop/hdfs/*:/usr/hadoop/hadoop/share/hadoop/mapreduce/lib/*:/usr/hadoop/hadoop/share/hadoop/mapreduce/*:/usr/hadoop/hadoop/share/hadoop/yarn:/usr/hadoop/hadoop/share/hadoop/yarn/lib/*:/usr/hadoop/hadoop/share/hadoop/yarn/*            </value>    </property></li></ol><!-- Site specific YARN configuration properties --></configuration>  <p>  <img src="/img/image-44.png" alt="image-44"><br>16. 修改workers<br>    <img src="/img/image-45.png" alt="image-45"><br>    <img src="/img/image-46.png" alt="image-46"><br>17. 启动时遇到问题<br>   <img src="/img/image-48.png" alt="image-48"><br>   查看日志，发现没有启动namenode，最后发现目录错误，根据下图目录以及对比搜索出来的目录可知，没有配置file<br>   <img src="/img/image-50.png" alt="image-50"><br>   查看目录<br>   <img src="/img/image-49.png" alt="image-49"><br>   跟换目录，重新修改配置，修改work等，运行成功</p>]]></content>
    
    
    <categories>
      
      <category>安装过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/09/23/hello-world/"/>
    <url>/2023/09/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
